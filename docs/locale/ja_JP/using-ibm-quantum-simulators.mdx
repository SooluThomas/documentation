---
title: IBM Quantum クラウドベースのシミュレータの使用
description: Qiskit RuntimeでIBM Quantumハードウェアデバイスの基本的なノイズモデルをマッピングします。
---

# IBM Quantum クラウドベースのシミュレータの使用

`ibmq_qasm_simulator` を設定し、Qiskit RuntimeでIBM Quantumハードウェアデバイスの基本的なノイズモデルをマップします。 次に、このノイズモデルを使用して、実際のデバイスで発生するエラーの影響を調べるために、`Sampler` と `Estimator` を使用して、`QuantumCircuits` のノイズシミュレーションを実行します。

## ローカル開発環境を設定

QisKit Runtime サービスインスタンスをまだ設定していない場合は、format@@0(../start/install) の手順に従ってください。

```python
# 必要なランタイムライブラリ
from qiskit_ibm_runtime import QiskitRuntime Service, Sampler, Estimator, Session, Options

service = QiskitRuntimeService()
```

## 環境の準備

最初に、例のルーチンを実行します。 プリミティブを使用する主な利点の1つは、パラメータ回路で複数のパラメータを簡素化することです。 これを示すために、次のコードで実装されている制御された [P-gate](/api/qiskit/qiskit.circuit.library.PhaseGate)を持つ回路例から始めます。 ここでは、回転パラメータ `theta` で `P-gate` をパラメータ化します。

```python
from qiskit.circuit import Parameter
from qiskit import QuantumCircuit

theta = Parameter('theta')

qc = QuantumCircuit(2,1)
qc.x(1)
qc.h(0)
qc.cp(theta,0,1)
qc.h(0)
qc.measure(0,0)

qc.draw('mpl')
```

![](/images/qiskit-ibm-runtime/noisy-sim-circuit.png)

以前に示した回路はパラメータ化され、固有値は量子ビット0に戻されて測定されます。 固有値の回転は、パラメータのシータによって決まります。 次に回路のパラメータをリストとして定義します。 この例のパラメータは、 $0$ から $2\\pi$までの範囲で、等間隔が 50 以上の点で割られます。

```python
import numpy as np

phases = np.linspace(0, 2*np.pi, 50)

# phases need to be expressed as a list of lists
individual_phases = [[phase] for phase in phases]
```

## 理想的なシミュレータで実行

### 使用するバックエンドとオプションを設定

最初の実行は、サンプラーと推定の両方で `noise_model` 、`optimization_level` または `弾力性_level` がなく、理想的なケースを想定しています。 以下のコードでオプションを定義します。

```python
backend = "ibmq_qasm_simulator" # シミュレータを使用
```

```python
options = Options()
options.simulator.seed_simulator = 42
options.execution.shots = 1000
options.optimization_level = 0 # no optimization
options.resilience_level = 0 # no error mitigation
```

### サンプラーで回路を実行

次に、サンプラーを使って回路をサンプリングし、結果として生じる準確率分布を得ます。 サンプラープリミティブの詳細については、[Get start with Sampler](../run/primitives-get-started#get-started-with-sampler) セクションを参照してください。

```python
samler = Sampler(options=options, backend=backend)
job = sampler.run(
    circuits=[qc]*len(phases),
    parameter_values=individual_phases
)
result = job.result()
```

```python
import matplotlib.pyplot as plt

# the probablity of being in the 1 state for each of these values
prob_values = [dist.get(1, 0) for dist in result.quasi_dists]

plt.plot(phases, prob_values, 'o', label='Simulator')
plt.plot(phases, np.sin(phases/2,)**2, label='Theory')
plt.xlabel('Phase')
plt.ylabel('Probability')
plt.legend()
```

```
<matplotlib.legend.Legend at 0x7f7fd233b6d0>
```

![](/images/qiskit-ibm-runtime/noisy-sim-sampler-ideal.png)

### 推定値で回路を実行

推定値プリミティブの詳細については、format@@0(../run/primitives-get-started#get-started-with-estimater) セクションを参照してください。

Estimatorは、量子演算子の期待値を返す前に、Hamiltoniansを得るために単一量子ビットの回転を結合します。 したがって、回路は測定を必要としません。 現在の回路`qc` には測定値がありますので、`remove_final_measurements` で削除します。

```python
qc_no_meas = qc.remove_final_measurements(inplace=False)
qc_no_measdraw('mpl')
```

![](/images/qiskit-ibm-runtime/noisy-sim-estimator-circuit.png)

```python

from qiskit.quantum_info import SparsePauliOp

ZZ= SparsePauliOp.from_list(["ZZ", 1])
print(f" > Observable: {ZZ.paulis}")
```

```
> 観測可能: ['ZZ']
```

この観測可能な場合、期待値は次の式に続く
によって計算されます。

$$    \\langle ZZ\\rangle =\\langle \\psi | ZZ | \\psi\\rangle=\\langle \\psi|(|0\\rangle\\langle 0| -|1\\rangle\\langle 1|)\\otimes(|0\\rangle\\langle 0| - |1\\rangle\\langle 1|) |\\psi\\rangle =|\\langle 00|\\psi\\rangle|^2 - |\\langle 01 | \\psi\\rangle|^2 - |\\langle 10 | \\psi\\rangle|^2 + |\\langle 11|\\psi\\rangle|^2$$

次のコードは期待値の式を実装しています。

```python
with Session(service=service, backend=backend):
    estimator = Estimator(options=options)
    job = estimator.run(
        circuits=[qc_no_meas]*len(phases),
        parameter_values=individual_phases,
        observables=[ZZ]*len(phases)
    )
    result = job.result()
```

```python
exp_values = result.values

plt.plot(phases, exp_values, 'o, label='Simulator')
plt.plot(phases, 2*np.sin(phases/2)**2-1, label='Theory')
plt.xlabel('Phase')
plt.ylabel('Expectation')
plt.legend()
```

```
<matplotlib.legend.Legend at 0x7f7fd0ed8820>
```

![](/images/qiskit-ibm-runtime/noisy-sim-estimator-ideal.png)

## ノイズの多いシミュレーションを実行

次に、理想的なシミュレーションではなく、ノイズの多いシミュレーションを実行するためのシミュレータを設定します。 `Options` パラメータに指定することで、QisKit Runtime シミュレータにカスタム `noise_model` を渡すことができます。 ここでは、`FakeBackend` クラスの `noise_model` を使用して実際のバックエンドを模倣します。 ノイズモデルは `FakeBackend` から抽出し、オプションで `simulator` パラメータとして渡すことができます。 詳細については、Qiskit Terra API リファレンスの [Fake Provider](/api/qiskit/providers_fake_provider) ドキュメントを参照してください。

我々は本当のバックエンドを模倣しようとしているので、 バックエンドのトポロジーの `couppuling_map` と `basis_gates` を渡して、より現実的なノイズシミュレーションを実現することもできます。

```python
from qiskit.providers.fake_provider import FakeManila
from qiskit_aer.noise import NoiseModel

# Make a noise model
fake_backend = FakeManila()
noise_model = NoiseModel.from_backend(fake_backend)

# Set options to include the noise model
options = Options()
options.simulator = {
    "noise_model": noise_model,
    "basis_gates": fake_backend.configuration().basis_gates,
    "coupling_map": fake_backend.configuration().coupling_map,
    "seed_simulator": 42
}

# Set number of shots, optimization_level and resilience_level
options.execution.shots = 1000
options.optimization_level = 0
options.resilience_level = 0
```

`ibmq_qasm_simulator` は、Qiskit Runtime サービスが提供する `resilience_levels` の有効化を可能にします。 シミュレータ上でこれらのレベルを使用することは、前述のようにノイズの多いシミュレーションを使用して実証されています。

比較を説明するために、`Options` の2つのセットを定義します。 ここで、`options` は `resilience level = 0` に設定され、エラー軽減なしで通常の実行を表します。 そして `options with em` は `resilience level = 1` に設定されており、エラー緩和が有効になっている実行を表します。

```python
# Set options to include the noise model with error mitigation
options_with_em = Options()
options_with_em.simulator = {
    "noise_model": noise_model,
    "basis_gates": fake_backend.configuration().basis_gates,
    "coupling_map": fake_backend.configuration().coupling_map,
    "seed_simulator": 42
}

# Set number of shots, optimization_level and resilience_level
options_with_em.execution.shots = 1000
options_with_em.optimization_level = 0 # no optimization
options_with_em.resilience_level = 1 # M3 for Sampler and T-REx for Estimator
```

`resilience_level` を 1 に設定すると、SamplerでM3が有効になります。
利用可能なレジリエンスレベルの設定は、format@@0(../run/configure-error-軽減)ページで説明されています。

```python
with Session(service=service, backend=backend):
    # include the noise model without M3
    sampler = Sampler(options=options)
    job = sampler.run(
        circuits=[qc]*len(phases),
        parameter_values=individual_phases
    )
    result = job.result()
    prob_values = [1-dist[0] for dist in result.quasi_dists]

    # include the noise model with M3
    sampler = Sampler(options=options_with_em)
    job = sampler.run(
        circuits=[qc]*len(phases),
        parameter_values=individual_phases
    )
    result = job.result()
    prob_values_with_em = [1-dist[0] for dist in result.quasi_dists]
```

```python
plt.plot(phases, prob_values, 'o, label='Noisy')
plt.plot(phases, prov_values_with_em, 'o, label='mitigated')
plt.plot(phases, np.sin(phases/2,)**2, label='Theory')
plt.xlabel('Phase')
plt.ylabel('Probability')
plt.legend()
```

```
<matplotlib.legend.Legend at 0x7f7fb4230700>
```

![](/images/qiskit-ibm-runtime/noisy-sim-sampler-noisy.png)

`T-REx` はレジリエンスレベルが次の値に設定されている場合に推定値でトリガーされます。

1.

```python
with Session(service=service, backend=backend):
    # include the noise model without T-REx
    estimator = Estimator(options=options)
    job = estimator.run(
        circuits=[qc_no_meas]*len(phases),
        parameter_values=individual_phases,
        observables=[ZZ]*len(phases)
    )
    result = job.result()
    exp_values = result.values

    # include the noise model with T-REx
    estimator = Estimator(options=options_with_em)
    job = estimator.run(
        circuits=[qc_no_meas]*len(phases),
        parameter_values=individual_phases,
        observables=[ZZ]*len(phases))
    result = job.result()
    exp_values_with_em = result.values
```

```python
plt.plot(phases, exp_values, 'o, label='Noisy')
plt.plot(phases, exp_values_with_em, 'o, label='mitigated')
plt.plot(phases, 2*np.sin(phases/2)**2-1, label='Theory')
plt.xlabel('Phase')
plt.ylabel('Expectation')
plt.legend()
```

```
<matplotlib.legend.Legend at 0x7f7f7006ca00>
```

![](/images/qiskit-ibm-runtime/noisy-sim-estimator-noisy.png)

抵抗レベルは現在ベータレベルにあるため、サンプリングオーバヘッドと
ソリューションの品質は回路によって異なります。 新機能、
高度なオプション、および管理ツールはローリング
ベースでリリースされます。 より高いレベルの回復力をテストし、
それらが提供する追加オプションを探索することもできます。 For more information
about activating features like `Digital-ZNE` and `PEC`, in addition to `M3` and `T-REx` as shown in the previous examples, see the [Error suppression and error mitigation with Qiskit Runtime](https://learning.quantum.ibm.com/tutorial/error-suppression-and-error-mitigation-with-qiskit-runtime) tutorial.

```python
import qiskit_ibm_runtime
qiskit_ibm_runtime.version.get_version_info()
```

```
'0.8.0'
```

```python
from qiskit.tools.jupyter import *
%qiskit_version_table
```

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - Qiskit Aer primitives(../run/configure-error-軽減)での Qiskit Runtime エラー軽減について学ぶ。
  - format@@0(https://learning.quantum.ibm.com/course/variational-algorithm-design/cost-functions)コースのエラー緩和オプションをご覧ください。
</Admonition>
