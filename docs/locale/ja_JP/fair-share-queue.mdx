---
title: Fair-shareのキュー
description: IBM Quantum fair-share キューが量子システムに送信されるジョブの順序を決定する方法
---

# Fair-shareのキュー

ジョブを量子システムに送信すると、特定のシステムのスケジューラが入力されます。 そのシステムで実行されるのを待っているすべてのユーザーからのジョブのプールに参加します。 これらのジョブが実行される順序は、デフォルトではフェアシェア式によって決定されます。 以下で説明されているように このアルゴリズムは、割り当てられたシステムアクセス量に従って、指定された時間ウィンドウ上で異なる [instances](インスタンス)間のワークロードのバランスをとることを試みます。 実際には、さまざまなインスタンスからのジョブが些細な方法で絡み合っていることを意味する。 仕事が完了する順序は必ずしも提出された順序ではありません 新しいジョブが到着するとキュー順序が動的に計算されるため、fair-share ジョブがいつ実行されるかを保証することは一般的に不可能です。

## Fair-share terms

-   **Provider:** 量子コンピューティングへのアクセスを提供するエンティティ。 IBM Quantum Platform および IBM Cloud®️ は Qiskit Runtime サービスのプロバイダーです。
-   **インスタンス:** hub/group/projectの組み合わせ。
-   **Hub:** 学術、産業、研究パートナーなどの組織のトップレベルを表します。
-   **グループ:** 1つまたは複数のユーザーのコレクション (プロジェクト) のためのハブによってアクセス共有を割り当てることができる中間レベルの構造。
-   **プロジェクト:** オーバーアーチンググループから共有を割り当てられたベースレベルの構築、および直接割り当てられたユーザー。
-   **共有へのアクセス** (このドキュメントでは簡略化された「共有」という用語を使用しています) 特定のハブ、グループ、プロジェクトに割り当てられた IBM Quantum コンピューティング サービスへの相対的なアクセス量。 アクセス部分は、分配された株式総数で割った株式の特定の割当てによって決定されます。 IBM Quantumは各ハブに、IBM Quantum Premium Planの全体的な計算能力のシェアを割り当てます。 Hub 管理者は、各グループに共有プールの分数を割り当てます。 最後に、グループ管理者はそれぞれのプロジェクトに共有プールの分数(株式とも呼ばれます)を割り当てます。
-   **スケジューリングウィンドウ:** フェアシェアアルゴリズムは、ロールタイムウィンドウ上での使用を考慮します。 公平性の目的は、そのウィンドウ内に蓄積された実行時間のみが占められます。 そのウィンドウの長さは現在28日です。 fair-share アルゴリズムが呼び出されると、28 日前から開始される使用状況が考慮されます。
-   **使用時間:** スケジューリングウィンドウ中に、すべてのグループとプロジェクトに対して、 私たちは、IBM Quantum Premium Planのすべてのシステムにおけるすべての使用状況を考慮しています。 これらには、既知の選択エラーを返すジョブだけでなく、すべての成功したジョブも含まれます。 部分的に実行された場合でも、キャンセルされたジョブは考慮されません。
-   **Fair-share algorithm:** 各グループとプロジェクトのために。 スケジューリングウィンドウの期間は、理想的な条件下でインスタンスが受け取る同等の時間に変換するために使用されます。 スケジューリングジョブの基盤として、使用される時間と同等の時間の割合が使用されます。

## 株式および管理

ハブの資格が、IBM Quantum Premium Planの計算能力の比例シェアを決定します。 IBM Quantumはハブに共有を割り当てます。 ハブ管理者は、これらの株式の各グループに割り当てる部分を決定します。 同様に、グループ管理者は各プロジェクトに割り当てる株式の部分を決定します。

![Administrator user interface.](/images/migration/admin-UI1.png)

Hub 管理ユーザー インターフェイス。 これはグループに株式を割り当てるために使用されます。 ハブ共有プール全体が基盤グループに分散されます。 ハブ管理者は、グループごとにシェア値を指定することでパーセント分配を制御できます。 この例では、グループ5はハブシェアプールの2株を受け取り、全グループで合計5株以上を受け取ります。 つまり、グループ5はハブに付与された株式プールの40%を受け取ることになります。

フェアシェアアルゴリズムでは、これらの株式がグループやプロジェクト間でどのように分配され、ジョブの優先順位を決定するかを考慮しています。

スケジューリングアルゴリズムは、グループの株式とハブの株式を組み合わせて、そのグループに割り当てられた計算電力の総割合を決定します。

![割り当ての計算方法を説明します](/images/migration/allocation.png)

Hub-Aの60%を計算する ハブAの3株から始まり、ハブレベル(3+2=5株)の全株式間で分けます。 これにより、3/5 = 0.6 = 60%となります。 分数をグループごとに計算する場合、各ハブ内で計算を繰り返します。 したがって、グループAとグループBの分数は33%、67%となります。 次に、これらのパーセンテージをハブA分数に適用し、20named@@0になります。

## フェアシェアキューの仕組み

fair-share スケジューリングアルゴリズムは、量子システム上で動的な順序で実行するジョブを選択します。これにより、インスタンスがシステムを独占できなくなります。 量子システムが追加の作業の準備ができたら、次のジョブをフェアシェアスケジューラに要求します。 スケジューラは、スケジューリングウィンドウ内で最も少ないシェアを使用したグループを最初に識別することで、次のジョブを選択します。 グループに複数のプロジェクトがあり、両方とも実行待ちのジョブがある場合。 スケジューラは、スケジューリングウィンドウで最小限のシェアを使用したプロジェクトを識別します。 最後に、プロジェクトが複数のジョブを送信した場合、スケジューラは最も古いジョブを最初に選択します。 したがって、プロジェクト内では、スケジューラはファーストインファーストアウト(FIFO)ベースで動作します。

次の例では、2つのハブの間に7つのインスタンスが配置されています。 ジョブがシステムを流れるにつれ、各グループとプロジェクトは効果的に割り当てられたシェアのほんの一部を消費します。 以下の最初の画像は、時t1の状態を示しています。 ブラケットの間には、割り当てられた株式の一部として消費を報告しています。 フェア共有アルゴリズムは最初に、括弧の間に最小の数字を持つグループを識別します。 ブラケットの中で最も少ない数のプロジェクトが最終的にそのプロジェクトによって提出された最も古い仕事を選択します

![Fair-share queue example.](/images/migration/fairshare3.png)

割り当てられた共有に対する消費(括弧内)のスナップショットビュー。 このシナリオには、7つの異なるH/G/Pがハブ、グループ、およびプロジェクトに配置されています。 次に選択されたグループまたはプロジェクトは、割り当てられた株式の最小消費割合を持つものです。 この例では、Hub-A/Group-1/Project-Y が選択され、プロジェクト内で最も古いジョブ (最初に送信) が実行されます。

システムが追加のジョブの準備ができたら、選択を繰り返します。 次の画像では、時間t2のキューの状態を表します。 なお、グループAとプロジェクトBの消費量は、t1とt2の間で発生した以前の消費量を考慮して更新されたことに注意してください。

![Fair-share queue example two.](/images/migration/fairshare4.png)

以前のジョブの実行を反映したフェア共有の優先順位を再設定しました。 新しいH/G/P(Hub-B/Group-2/Project-N)が更新された値に基づいて選択されます。

ユーザーが特定の IBM Quantum システムにジョブを送信する場合に注意してください。 フェアシェアアルゴリズムアカウントは、公平性を決定する際に、IBM Quantum Premium Plan内のユーザーが利用可能なすべてのシステムで使用されることを考慮します。

## キューでの私の仕事の位置は何ですか？

上記のように、同じプロジェクトを通じてスケジューラに送信されたすべてのジョブはFIFO順序で実行されます。 しかし、グローバルな実行順序は、fair-share アルゴリズムによって管理されます。 その結果 ジョブ送信とジョブ実行の間の時間は、システムをアクティブに待機しているインスタンスの使用パターンによって変動する可能性があります。

待機時間の見積もりは、IBM Quantum PlatformとQiskitを介して提供されます。 計算時間は、1つの可能な実行パターンを予測するスケジューリングシミュレーションの結果です。 システムを待つ全てのジョブの現在の公平な共有順序と各ジョブの大まかな実行状況を考えると fair-share アルゴリズムの動的な性質は、この推定時間が固定されておらず、時には劇的に変動する可能性があることを意味します。 この待ち時間も、Qiskit Runtime ジョブの実行時間の推定に固有の制限の対象となります。 これらのジョブでは、正確な時間の推定が不可能である場合、許容される最大ランタイムがプロキシとして使用されます。 実際には、Qiskit Runtimeジョブの期間を最大8時間まで過大評価できることを意味します。 プレミアムプランをご利用のお客様に、Qiskit Runtimeジョブの最大許容期間を設定します。

キュー内のジョブの位置は、format@@0(https://quantum.ibm.com/jobs)の**キュー位置**列にリストされています。

## 次のステップ

<Admonition type="tip" title="Recommendations">
    - format@@2(https://learning.quantum.ibm.com/tutorial/grovers-algorithm) チュートリアルを試してみてください。
    - format@@0(monitor-job) の方法を学びます。
</Admonition>
