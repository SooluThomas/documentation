---
title: セッションでジョブを実行
description: セッションでジョブを実行
---

# セッションでジョブを実行

[sessions](セッション)の設定と使用方法はいくつかあります。  単一のジョブでセッションを実行しないことをお勧めします。

## セッションを使用するよう設定

セッションを開始する前に、format@@0(../start/install) とサービスとして初期化する必要があります。

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler, Estimator

service = QiskitRuntimeService()
```

## セッションを開く

`with Session(...)` コンテキストマネージャを使用するか、 `Session`
クラスを初期化することで、ランタイムセッションを開くことができます。 セッションは、最初のジョブが実行を開始すると開始されます。 

<Admonition type="note" title="Important">
    最初のセッションジョブがキャンセルされた場合、その後のセッションジョブはすべて失敗します。
</Admonition>

**Session class**

```python
from qiskit_ibm_runtime import Session, Sampler, Estimator

session = Session(service=service, backend="ibmq_qasm_simulator")
estimator = Estimator(session=session)
sampler(session=session)
```

**コンテキストマネージャー**

コンテキストマネージャは自動的にセッションを開閉します。

```python
with Session(service=service, backend="ibmq_qasm_simulator"):
  estimator = Estimator()
  sampler = Sampler()
```

セッションを開始するときは、バックエンドを指定する必要があります。 これは、名前を指定するか、バックエンドオブジェクトを渡すことで行うことができます。 

**バックエンドを名前で指定**

```python
service = QiskitRuntimeService()
with Session(service=service, backend="ibmq_qasm_simulator"):
...
```

**バックエンドオブジェクトを渡す** 

```python
backend = service.get_backend("ibmq_qasm_simulator")
with Session(backend=backend):
...
```

<span id="specify-length"></span>
## セッション長

max_timeパラメータで最大セッションタイムアウトを定義できます。 これは、最長のジョブの実行時間を超え、システムの制限内にある必要があります。 

```python
with Session(service=service, backend=backend, max_time="25m"):
...   
```

設定できないインタラクティブなタイムアウト値 (ITTL、またはライブまでのインタラクティブな時間) もあります。  そのウィンドウ内でセッションジョブがキューイングされていない場合、セッションは一時的に無効になります。 セッションの ITTL を決定するには、format@@0(#session-details) の指示に従って、`interactive_timeout` 値を探します。

<span id="close"></span>
## セッションを閉じる

コンテキストマネージャを終了すると、セッションが自動的に閉じます。 qiskit-ibm-runtime 0.13 以降のリリースでは、セッションコンテキストマネージャが終了すると、セッションは「進行中で、新しいジョブを受け入れるのではなく」の状態になります。 これは、最大タイムアウト値に達するまで、セッションがすべての実行中またはキューされたジョブの処理を終了することを意味します。 すべてのジョブが完了すると、セッションはすぐに閉じられます。 これにより、スケジューラはセッションのインタラクティブなタイムアウトを待たずに次のジョブを実行することができ、それによって平均ジョブキューイング時間を短縮できます。 閉じたセッションにジョブを送信することはできません。

```python
with Session(service=service, backend=backend) as session:
    estimator = Estimator()
    job1 = estimator.run(...)
    job2 = estimator.run(...)
    
# The session is no longer accepting jobs but the submitted job will run to completion.    
result = job1.result()
result2 = job2.result()
```

コンテキストマネージャを使用していない場合は、必要な結果がすべて取得されたら手動でセッションを閉じることをお勧めします。 qiskit-ibm-runtime 0.13 以降のリリースでは、`sessionでセッションが閉じられたとき。 lose()`は新しいジョブを受け付けなくなりましたが、すでに送信されたジョブは完了まで実行され、結果を取得することができます。 qiskit-ibm-runtime 0.13 より前のバージョンでは、セッションが `session で閉じられています。 lose()`は、すでに実行されているジョブを実行し続けますが、セッションに残っているキューされたジョブはすべて失敗状態になります。

```python
session = Session(backend=backend)
estimator = Estimator(session=session)
job1 = estimator.run(...)
job2 = estimator.run(...)
print(f"Result1: {job1.result()}")
print(f"Result2: {job2.result()}")

# Manually close the session. Running and queued jobs will run to completion.
session.close()
```

<Admonition type="caution" title="When the root job is canceled">
セッションでルートジョブをキャンセルした場合（セッションと同じIDを持つジョブ）に注意してください。 セッションが閉じられ、セッションのキューに入ったジョブが失敗します。
</Admonition>

<span id="cancel"></span>
## セッションをキャンセル

セッションをキャンセルすると、即座に終了し、キューに入れられたすべてのジョブに失敗し、新しい提出を防止します。 セッションをキャンセルするには、`session.cancel()`メソッドを使用します。  すでに実行されているジョブは引き続き実行されますが、キューされたジョブは失敗した状態に追加され、セッションにそれ以上のジョブを送信することはできません。 これはセッション内のすべてのキューに入ったジョブをすばやく失敗させる便利な方法です。 

```python
with Session(service=service, backend=backend) as session:
    estimator = Estimator()
    job1 = estimator.run(...)
    job2 = estimator.run(...)
    # You can use session.cancel() to fail all pending jobs, for example, 
    # if you realize you made a mistake.
    session.cancel()
```

## セッションで複数のプリミティブを呼び出します

セッションは複数のプリミティブを扱うことができ、1つのセッション内で様々な操作を行うことができます。  以下の例では、`Sampler`クラスのインスタンスと`Estimator`クラスのいずれかを作成し、セッション内で`run()`メソッドを呼び出す方法を示しています。 

````python
from qiskit_ibm_runtime import Session, Sampler, Estimator

with Session(backend=backend):
    sampler = Sampler()
    estimator = Estimator()

    result = sampler.run(sampler_circuit).result()
    print(f">>> Quasi-probability distribution from the sampler job: {result.quasi_dists[0]}")

    result = estimator.run(circuit, observable).result()
    print(f">>> Expectation value from the estimator job: {result.values[0]}")
    ```
<span id="session-status"></span>
## Check session status

You can query a session's status to understand its current state by using  `session.status()` or on the Jobs page for your channel.

Session status can be one of the following:

- `Pending`: The session has not started or has been deactivated. The next session job needs to wait in the queue like other jobs. 
- `In progress, accepting new jobs`: The session is active and accepting new jobs.
- `In progress, not accepting new jobs`: The session is active but not accepting new jobs. Job submission to the session is rejected, but outstanding session jobs will run to completion. The session is automatically closed once all jobs finish. 
- `Closed`: The session's maximum timeout value has been reached or the session was explicitly closed.

<span id="session-details"></span>
## Determine session details

For a comprehensive overview of a session's configuration and status, use the  `session.details() method`. 

``` python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()

with Session(service=service, backend="ibmq_qasm_simulator") as session:
    estimator = Estimator()
    job = estimator.run(circuit, observable)
    print(session.details())
````

 format@@0(https://quantum.ibm) でセッションの詳細を確認することもできます。 format@@0(https://cloud.ibm.com/quantum/instances)からアクセスできるIBM Cloud Jobs ページまたは。 

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - [量子近似最適化アルゴリズム(QAOA)](https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm) チュートリアルの例を試してみてください。 
  - format@@0(https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Session) リファレンスを確認してください。
</Admonition>
