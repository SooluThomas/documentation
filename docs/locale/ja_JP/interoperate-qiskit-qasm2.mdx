---
title: OpenQASM 2 と Qiskit
description: OpenQASM 2 と Qiskit 間のコード変換
---

# OpenQASM 2 と Qiskit

Qiskitは、量子プログラムのOpenQASM表現と [QuantumCircuit](../api/qiskit/qiskit.circuit.QuantumCircuit)クラスの間で変換するためのツールを提供しています。

## OpenQASM 2 プログラムを Qiskit にインポート

現在、OpenQASM 2 から Qiskit へのインポートには 2 つの高レベル関数が利用できます。 これらの関数はファイル名を取る`qasm2.load()`で、プログラム自体を文字列とする`qasm2.loads()`です。 

```python
qiskit.qasm2.load(filename, *, include_path=('.',), include_input_directory='append', custom_instructions=(), custom_classical=(), strict=False)
```

詳細については、[OpenQASM 2 Qiskit API](/api/qiskit/qasm2) を参照してください。 

### 例: OpenQASM 2 プログラムを文字列としてインポート

OpenQASM 2プログラムを文字列としてQuantumCircuitにインポートするには、`qasm2.loads()`を使用します。

```python
import qiskit.qasm2
program = '''
    OPENQASM 2.0;
    include "qelib1.inc";
    qreg q[2];
    creg c[2];

    h q[0];
    cx q[0], q[1];

    measure q -> c;
'''
circuit = qiskit.qasm2.loads(program)
circuit.draw()
```

![output](/images/build/qasm2.png)

### 例: OpenQASM 2 プログラムをファイルからインポート

`load()`を使用して、OpenQASM 2プログラムをファイルからQuantumCircuitにインポートします。

```python
import qiskit.qasm2
circuit = qiskit.qasm2.load("myfile.qasm")
```

<span id="custom-instructions"></span>
## カスタム量子命令

`custom_instructions`引数としてカスタム命令に関する情報を反復的に渡すことで、OpenQASM 2言語の量子コンポーネントを拡張できます。 これらの命令に互換性のある定義を持つファイルでは、与えられたコンストラクタは `qiskit.qasm2` 以外の処理を行う代わりに使用されます。  パースされたプログラムで定義された命令とは異なる数のパラメータまたは量子ビットを持つカスタム命令を提供することはできません。 引数の各要素は以下のように特定のデータクラスでなければなりません:

#### `qiskit.qasm2.CustomInstruction(name, num_params, num_qubits, constructor, builtin=False)`

CustomInstructionクラスは、解析中に定義されるカスタム命令に関する情報を提供します。

`constructor` フィールドは、シグネチャの `*args -> Instruction` を含む呼び出し可能なオブジェクトでなければなりません。この場合、`num_params` args はそれぞれ浮動小数点値です。 ほとんどの組み込みQiskitゲートクラスはこのフォームを持っています。

`built`フィールドは任意です。 `true` に設定すると、命令が定義され、パース内で使用可能になります。 含まれている OpenQASM 2 ファイルに定義がない場合でも。 `built`としてマークされた命令は不透明またはゲート宣言を必要としませんが、それらは静かに互換性のある宣言を無視します。

### 例: カスタム量子命令の使用

OpenQASM 2 プログラムを文字列として QuantumCircuit にインポートするには、`qasm2.loads()` を使用しますが、カスタムの量子命令を使用します。  場合によっては、インポーターが指定された命令に対して出力するゲートオブジェクトに影響を与えることもあります。 \`include "qelib1.inc"で定義されたゲートは、適切なQiskit回路ライブラリゲートと自動的に関連付けられますが、これを拡張することができます。

```python
from qiskit.circuit import Gate
from qiskit import qasm2

class MyGate(Gate):
    def __init__(self, theta):
        super().__init__("my", 2, [theta])

class Builtin(Gate):
    def __init__(self):
        super().__init__("builtin", 1, [])

program = '''
    opaque my(theta) q1, q2;
    qreg q[2];
    my(0.5) q[0], q[1];
    builtin q[0];
    '''
customs = [
    qasm2.CustomInstruction(name="my", num_params=1, num_qubits=2, constructor=MyGate),
    # Setting 'builtin=True' means the instruction doesn't require a declaration to be usable.
    qasm2.CustomInstruction("builtin", 0, 1, Builtin, builtin=True),
]
circuit = qasm2.loads(program, custom_instructions=customs)
```

<span id="custom-classical"></span>
## カスタム古典関数

`custom_classical` にiterableを渡すことで、古典式 (gatesへの引数) への処理を拡張できます。 これは名前(有効な OpenQASM 2 識別子)と、引数の数 (num_params) と、関数を実装する Python 呼び出し可能が必要です。 呼び出し可能なPythonは、 `num_params` 位置浮動小数点引数を受け付ける必要があります。 そして、float または integer (floatに変換されます) を返す必要があります。 組み込み関数は上書きできません。 

#### `qiskit.qasm2.CustomClassical`

`CustomClassical` クラスは、数式で定義されるべきカスタム古典関数に関する情報を提供します。

与えられた `callable` は、 `num_params` 浮動小数点数を受け取って float を返すPython関数でなければなりません。 `name` は、OpenQASM 2 プログラム内でそれを参照する識別子です。 これは、定義されたゲートと衝突することはできません。

### 例: カスタム古典命令を使用する

OpenQASM 2プログラムを文字列としてQuantumCircuitにインポートするには`qasm2.loads()`を使用しますが、カスタムの古典命令を使用します。  ゲートへの引数の説明で使用される新しい古典関数を追加できます。 プログラムの本体(定数で折り畳まれて出てくる)と、定義されたゲート(要求に応じて計算される)の本体内の両方。 ここでは数学的に $\\atan(y/x)$ のPythonバージョンの `atan2(y, x)` を提供しますが、角度の四角と無限大を正しく処理し、カスタムの `add_one` 関数を提供します。

```python
import math
from qiskit.qasm2 

program = '''
    include "qelib1.inc";
    qreg q[2];
    rx(atan2(pi, 3 + add_one(0.2))) q[0];
    cx q[0], q[1];
'''

def add_one(x):
    return x + 1

customs = [
    # `atan2` takes two parameters, and `math.atan2` implements it.
    qasm2.CustomClassical("atan2", 2, math.atan2),
    # Our `add_one` takes only one parameter.
    qasm2.CustomClassical("add_one", 1, add_one),
]
circuit = qasm2.loads(program, custom_classical=customs)
```

<span id="strict"></span>
## Strict mode

デフォルトでは、このパーサは公式の仕様よりも少しリラックスしています。 パラメータリストにコンマを続けることができます。不要な (空白文) セミコロン、 `OPENQASM 2. ;` バージョンステートメントを省略する必要があります。その他、エラーを発生させることなく、いくつかの品質向上があります。 しかし、`strict=True`では、"letter-of-the-spec"モードを使うことができます。

## 次のステップ

<Admonition type="tip" title="Recommendations">
    - format@@2(https://learning.quantum.ibm.com/tutorial/explore-gates-and-circuits-with-the-quantum-composer)チュートリアルでOpenQASMコードを生成する方法を学びます。
    - format@@0(/api/qiskit/qasm2) 参照を参照してください。
    - format@@0(../verify/) のトピックを確認します。
    - format@@0(https://openqasm.com/) を参照してください。
</Admonition>
