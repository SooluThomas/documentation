---
title: トランスパイラーの最適化レベルを設定
description: 最適化レベルを設定する方法を学ぶ
---

# 最適化レベルを設定する

対象デバイスの基底ゲートセットに量子回路を分解し、ハードウェアトポロジーに合わせてSWAPゲートを追加すると、量子回路の深度とゲートカウントが増加します。 この複雑さを軽減するために、 `optimization_level` を設定します。  この値を設定すると、(選択されたレベルに応じて)最適なレイアウトを見つけるためにアルゴリズムを使用してゲートを組み合わせるか除去することによって、トランスパイルプロセスを最適化する最適化ルーチンが呼び出されます。 

場合によっては、これらの方法が非常に有効であるため、出力回路は入力よりも深度が低くなります。 また、ノイズの多いデバイスでは計算が困難な場合もあります。 最適化レベルを選択すると、最適化レベルが試行錯誤する可能性があります。これは、回路がトランスパイルされ、バックエンドがターゲットにされていることに大きく依存するためです。

最適化レベルが高いほど、コンパイル時間が長くなるため、より多くの最適化回路が生成されます。  デフォルトでは `optimization_level=1` が使用されます。 

-   `optimization_level=0`: 明示的な最適化なしでバックエンドに回路をマップするトリビアル最適化。
-   `optimization_level=1-3`: ますます複雑な最適化を行い、レイアウトを見つけてSWAPゲートを挿入するために使用されるヒューリスティックアルゴリズムを使用します。 回路全体のパフォーマンスを向上させることを目標にしています  これらのアルゴリズムが実行される反復回数は、最適化レベルが高いほど増加します。 

最適なレイアウトを見つけることはNP難しい問題であるため、移調プロセスの中で最も時間のかかる部分です。  しかし、QiskitはRustにリファクタリングされた確率アルゴリズムを使用し、結果として大幅なスピードアップをもたらします。  したがって、最適化レベル1~3はすべて同じレイアウトアルゴリズムを使用します。  回路が基底ゲートに変換される方法には、以下の表のように若干の違いがあります。

<Table>
  <thead>
    <Tr>
      <Th>Optimization Level</Th>
      <Th>Description</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>0</Td>
      <Td>
        No optimization: typically used for hardware characterization
        - Basic translation
        - Layout/Routing: `TrivialLayout`, where it selects the same physical qubit numbers as virtual and inserts SWAPs to make it work (using `StochasticSwap`)
      </Td>
    </Tr>
    <Tr>
      <Td>1</Td>
      <Td>
        Light optimization (default):
        -   Layout/Routing: Layout is first attempted with `TrivialLayout`. 追加のSWAPが必要な場合は、 `SabreSWAP`を使って最低限のSWAP数のレイアウトを見つけることができます。 次に、`VF2LayoutPostLayout` を使って、グラフ内の最適な量子ビットを選択します。
        -   InverseCancellelation
        -   1Q gate optimization
      </Td>
    </Tr>
    <Tr>
      <Td>2</Td>
      <Td>
        Medium optimization:
          - Layout/Routing: Optimization level 1 (without trivial) + heuristic optimized with greater
        search depth and trials of optimization function.  `TrivialLayout` は使用されないため、同じ物理的な qubit 番号と仮想的な qubit 番号を使用しようとする試みはありません。 
        -   Commutative cancelation
      </Td>
    </Tr>
    <Tr>
      <Td>3</Td>
      <Td>
        High Optimization:
        - Optimization level 2 + heuristic optimized on layout/routing further with greater effort/trials
        - Resynthesis of two-qubit blocks using [Cartan's KAK Decomposition](https://arxiv.org/abs/quant-ph/0507171). 
        - Unitarity-breaking passes: 
          * `OptimizeSwapBeforeMeasure`: Moves the measurements around to avoid SWAPs
          * `RemoveDiagonalGatesBeforeMeasure`: Removes gates before measurements that would not effect the measurements
      </Td>
    </Tr>
  </tbody>
</Table>

## アクションの最適化レベル

CXは最もノイズの高いゲートなので、CXゲートを計算することでトランスパイルの「ハードウェア効率」を定量化することができます。 同じ回路を与えられたデフォルトのトランスパイルレベルを比較します。 

まず、必要なライブラリをインポートします。

```python
from qiskit import transpile, QuantumCircuit
from qiskit.circuit.library import UnitaryGate
from qiskit.providers.fake_provider import FakeTokyo
from qiskit.quantum_info import Operator, random_unitary
from qiskit.quantum_info.synthesis.two_qubit_decompose import trace_to_fid

import numpy as np
```

次に、ランダムなユニタリーとSWAPゲートで構成される量子回路を構築します。 `random_unitary` メソッドは再現性のある結果を保証するためにシードされます。

```python
UU = random_unitary(4, seed=12345)
rand_U = UnitaryGate(UU)

qc = QuantumCircuit(2)
qc.append(rand_U, range(2))
qc.swap(0, 1)
qc.draw('mpl')
```

![Original abstract circuit](/images/transpile/defaults-and-configuration-options/abstract-circ.png)

バックエンドとして `FakeTokyo` を使用し、トランスパイルは `optimization_level=1` (デフォルト) を使用します。 アイドル量子ビットの影響を考慮しないように、トランスパイルされた回路が2量子ビット回路に戻るように、バックエンドのカップリングマップをオーバーライドします。

```python
backend = FakeTokyo()
qc_t1_exact = transpile(qc, backend, optimization_level=1, coupling_map=[[0, 1, 0]], seed_transpiler=12345)
qc_t1_exact.draw('mpl', style='iqp')
```

![Circuit transpiled with optimization level 1](/images/transpile/defaults-and-configuration-opt-level-1.png)

トランスパイルされた回路には6つのCXゲートといくつかの`U3`ゲートがあり、CXよりもはるかに低い誤差を持っているため、カウントする必要はありません。 

最適化レベル2の繰り返し: 

```python
qc_t2_exact = transpile(qc, backend, optimization_level=2, coupling_map=[[0, 1, 0]], seed_transpiler=12345)
qc_t2_exact.draw('mpl', style='iqp')
```

![Circuit transpiled with optimization level 2](/images/transpile/defaults-and-configuration-opt-level-2.png)

これにより、最適化レベル1と同じ結果が得られます。 最適化のレベルを上げると必ずしも違いはないことに注意してください。 

最適化レベル3でもう一度繰り返します。

```python
qc_t3_exact = transpile(qc, backend, optimization_level=3, coupling_map=[[0, 1, 0]], seed_transpiler=12345)
qc_t3_exact.draw('mpl', style='iqp')
```

![Circuit transpiled with optimization level 3](/images/transpile/defaults-and-configuration-opt-level-3.png)

今CXゲートは3つしかありません。 これは、最適化レベル3の場合、Qiskitは2量子ビットのゲートブロックを再合成しようとするためです。 2量子ビットゲートは最大3つのCXゲートを必要とするため、上記の結果を得ることができます。 `approximation _degree` を 1 より小さい値に設定することで、このシンセの忠実度を犠牲にすると、CXゲートの数はさらに少なくなります。

```python
qc_t3_approx = transpile(qc, backend, optimization_level=3, approxilation_degree=0.99, coupping_map=[[0, 1, 0]], seed_transpiler=12345)
qc_t3_approx.draw('mpl', style='iqp')
```

この回路には2つのCXゲートしかありません。 しかし、これはおおよその回路です。 ノイズ量子ビット上を走ることで発生した誤差を持つ所望の回路と忠実度の違いを理解する必要があります 近似回路の忠実度を計算することができます:

```python
exact_fid = trace_to_fid(np.trace(np.dot(Operator(qc_t3_exact).adjoint().data, UU)))
approx_fid = trace_to_fid(np.trace(np.dot(Operator(qc_t3_approx).adjoint().adjoint().data())))
print(f'Synthesis fidity\nExact: {exact_fid:.3f}\n想定値: {approx_fid:.3f}')
```

```text
合成忠実度
正確: 1.000
近似: 0.992
```

最適化レベルを調整すると、CXゲートの数だけでなく、回路の他の側面も変化する可能性があります。 最適化レベルがレイアウトにどのように変化するかについては、format@@0(representing_quantum_computers)を参照してください。

## 次のステップ

<Admonition type="tip" title="Recommendation">
    - [Default options and configurations settings](defaults-and-configuration-options)
    - [Common-parameters](common-parameters)
    - [Submit transpiled circuits](https://learning.quantum.ibm.com/tutorial/submit-transpiled-circuits) チュートリアルを試してみてください。

</Admonition>

## 次のステップ

<Admonition type="tip" title="Recommendations">
    - `transpile` 関数の使い方を学ぶには、[Transpilation default settings and configuration-options](defaults-and-configuration-options) トピックから始めます。
    - format@@0(transpiler-stages) トピックで移調について学び続けましょう。
    - format@@0(https://learning.quantum.ibm.com/tutorial/submit-transpled-circuits) チュートリアルを試してみてください。
    - format@@0(https://learning.quantum.ibm.com/tutorial/build-反復コード) チュートリアルを試してみてください。
    - [Transpile API documentation.](/api/qiskit/transpiler)
</Admonition> を参照してください。
