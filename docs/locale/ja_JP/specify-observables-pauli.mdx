---
title: パウリ基準で観察可能を指定します
description: 計算に基づいて対角線ではない観測値を測定するために必要な、さまざまなパウリベースの測定回路。
---

# パウリ基準で観察可能を指定します

量子力学では、観測可能性は測定可能な物理特性に相当します。
例えば、スピンのシステムを検討する場合 システムのエネルギーの測定やスピンの配置に関する情報の取得に関心があるかもしれません 磁化やスピン間の相関関係などです

量子コンピューター上で観測可能な $n$-qubit $O$ を測定する パウリ演算子のテンソル産物の合計として表現しなければなりません

$$
O = \\sum\_{k=1}^K \\alpha_k P_k,~~ P_k \\in{I, X, Y, Z}^{\\otime n},~~ \\alpha_k \\in \\mathbb{R},
$$

どこで 

$$
I = \\begin{pmatrix}
1 & 0 \\ 0 & 1
\\end{pmatrix}
~~
X = \\begin{pmatrix}
0 & 1 \\ 1 & 0
\\end{pmatrix}
~~
Y = \\begin{pmatrix}
0 & -i \\ i & 0
\\end{pmatrix}
~~
Z = \\begin{pmatrix}
1 & 0 \\ 0 & -1
\\end{pmatrix}
$$

そして、観察可能なものがエルミチアンであるという事実を使用します。 $O^\\dagger = O$。 $O$ がエルミチアンでない場合でもパウリスの和として分解することができますが、係数$\\alpha_k$は複雑になります。

多くの場合、対象となるシステムを qubit にマッピングした後、observable はこの表現で自然に指定されます。
たとえば、スピン1/2システムをIsing Hamiltonianにマップすることができます。

$$
H = \\sum_{\\langle i, j\\rangle} Z_i Z_j - \\sum_{i=1}^n X_i,
$$

ここで、相互に作用するスピン上で $\\langle i, j\\rangle$ が実行され、スピンは $X$ の横断フィールドの対象となります。
下付きインデックスは、パウリ演算子がどの量子ビットを動作させるかを示します。すなわち、 $X_i$ は qubit $X$ に $i$ 演算子を適用し、残りの部分は変更されません。
Qiskitでは、このハミルトニアンを次のように構築することができます 

```python
from qiskit.quantum_info import SparsePauliOp
# define the number of qubits
n = 12

# define the single Pauli terms as ("Paulis", [indices], coefficient)
interactions = [("ZZ", [i, i + 1], 1) for i in range(n - 1)]  # we assume spins on a 1D line
field = [("X", [i], -1) for i in range(n)]

# build the operator
hamiltonian = SparsePauliOp.from_sparse_list(interactions + field, num_qubits=n)
```

エネルギーを計測したいのであれば、観測できるのはハミルトン自体です。 Alternatively, we could be
interested in measuring system properties like the average magnetization by counting the number of spins 
aligned in the $Z$-direction with the observable

$$
O = \\frac{1}{n} \\sum\_{i=1} Z_i
$$

Pauli 演算子ではなく行列で指定された監視可能。 量子コンピュータで評価するためにはまず、パウリベースで
を再定式化しなければなりません。
パウリ行列がエルミチアンの $2^n \\times 2^n$ 行列の基礎を形成するような表現をいつでも見つけることができます。
観測可能な $O$ を拡張します。 

$$
O = \\sum\_{P {I, X, Y, Z}^{\\otime n}} \\mathrm{Tr}(O P) P,
$$

ここで、この合計は可能なすべての $n$-qubit Pauli用語で、$\\mathrm{Tr}(\\cdot)$ は行列のトレースです。 内側の製品として機能しています
以下のように、 `SparsePauliOp.from_operator` メソッドを使用して、行列からパウリの用語へのこの分解を実装できます。

```python
import numpy as np
from qiskit.quantum_info import SparsePauliOp

matrix = np.array([[-1, 0, 0.5, -1],
		   [0, 1, 1, 0.5],
		   [0.5, 1, -1, 0],
		   [-1, 0.5, 0, 1]])

observable = SparsePauliOp.from_operator(matrix)
print(observable)  
```

どの印刷

```
SparsePauliOp(['IZ', 'XI', 'YY'], coeffs=[-1. +0.j,  0.5+0.j,  1. +0.j])
```

つまり、行列は $O = -Z_1 + 0.5 X_2 + Y_2 Y_1$ と書くことができます。

<Admonition type="note">
  テンソル製品の順序は、量子ビットに $q_n \othes q_{n-1} \othes \cdots \otime q_1$としてマップすることを忘れないでください。
</Admonition>

<Admonition type="note">
  観測可能なエルミチアン( $O^\dagger = O$の意味)の場合、パウリ係数は実数です。
  しかし、複雑な値の係数を許せば、他の複雑な行列をパウリスの観点から分解することもできます。
</Admonition>

## パウリ基地内の測定

測定値は量子ビットの状態を ${|0\\r角度, |1\\r角度}$にします. つまり、ポールは $I$ と $Z$ の用語のみで構成されるように、この基準で対角線である観測値のみを測定することができます。
従って、任意のパウリ用語を測定するには、それらを対角化するための基礎の変更が必要です。 これを行うには、次の変換を実行します。

$$
\\begin{aligned}
    X &\\rightarrow Z = H X H \\
    Y &\\rightarrow Z = H S^\\dagger Y S H,
\\end{aligned}
$$

$H$ はハダマードゲートで、 $S = \\sqrt{Z}$ はフェーズゲートと呼ばれることがあります。 
期待値を計算するために [Estimator](../api/qiskit/qiskit.primitives.Estimator) を使用している場合、基本変換は自動的に実行されます。

以下は、量子回路を作成し、X単位で量子ビット0を手動で測定する方法を示す例です。 
量子ビットはYベースで1、量子ビットはZベースで2。 
以前の式に示した変換を適用して、次の回路を得ます。

```python
from qiskit.circuit import QuantumCircuit

# create a circuit, where we would like to measure
# q0 in the X basis, q1 in the Y basis and q2 in the Z basis
circuit = QuantumCircuit(3)
circuit.ry(0.8, 0)
circuit.cx(0, 1)
circuit.cx(1, 2)
circuit.barrier()

# diagonalize X with the Hadamard gate 
circuit.h(0)

# diagonalize Y with Hadamard as S^\dagger
circuit.h(1)
circuit.sdg(1)

# the Z basis is the default, no action required here

# measure all qubits
circuit.measure_all()
circuit.draw()
```

![output](/images/build/paulibasis.png)

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - [Variational quantum eigensolver](https://learning.quantum.ibm.com/tutorial/variational-quantum-eigensolver)チュートリアルで回路分解の例を参照してください。
  - [SparsePauliOp API](/api/qiskit/qiskit.quantum_info.SparsePauliOp#sparsepauliop) リファレンスを読んでください。
</Admonition>
