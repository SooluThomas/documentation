---
title: セッション
description: セッションの概要とそれらをいつ使用するか。
---

# Qiskit ランタイムセッション入門

セッションは Qiskit Runtime 機能で、量子コンピューター上でマルチジョブの反復ワークロードを効率的に実行できます。 セッションを使用すると、ジョブごとに別々にキューに追加される遅延を回避できます 古典リソースと量子リソースの間の頻繁な通信を必要とする反復タスクに特に有用です。

<Admonition type="note">
セッション内で最初に送信されたジョブの待ち時間は減少しません。 したがって、セッションは単一のジョブを実行する際に一切の利点を提供しません。
</Admonition>

## セッションを使用する利点

セッションを使用するにはいくつかの利点があります。

-   効率性: 1つのアルゴリズムで実行された複数のジョブを、中断することなく連続的に実行できます。
-   柔軟性: 新しいジョブを開始することなく、アクティブなセッション内でジョブを送信したり、結果を確認したり、新しいジョブを送信したりできます。

## セッションの仕組み

セッションの基本的なワークフローは次のとおりです。

1.  セッションの最初のジョブは通常のキューに入ります。 
2.  最初のジョブの実行を開始すると、_最大タイムアウト_クロックが開始されます。 
3.  セッション内のその後のジョブは他のジョブより優先され、待ち時間が短縮されます。
4.  _interactive timeout_ はセッション内のジョブ間で実行されます。 各セッションにはインタラクティブなタイムアウト値(ITTL、またはライブするインタラクティブな時間)があります。 ITTL ウィンドウ内にキューイングされたセッションジョブがない場合、セッションは一時的に無効化され、通常のジョブ選択が再開されます。 セッションが最大タイムアウト値に達していない場合、次のジョブ<sup>\*</sup> で無効化されたセッションを再開することができます。
5.  最大タイムアウト値に達した場合、セッションは終了し、残りのキュージョブは失敗します。

<Admonition type="note">
* セッションを再開するには、ジョブは通常のキューを通過する必要があります。
</Admonition>

セッションの最大セッションタイムアウト値を見つけるには、[Determine session details](run-jobs-in-session#session-details)の指示に従ってください。

<Admonition type="note">
    お使いのハブがプレミアム、オープン、などによってはITTLの値に制限が課せられる場合があります。 
</Admonition>

セッションを開始する手順については、format@@0(run-jobs-in-session)を参照してください。

<span id="ends"></span>
## セッション終了

セッションは以下の状況で終了できます: 

-   最大タイムアウトに達し、すべてのキューに入れられたジョブがキャンセルされます。 
-   セッションは手動でキャンセルされ、キューに入れられたすべてのジョブがキャンセルされます。
-   セッションは手動で閉じられます。  セッションは新しいジョブの受け入れを停止しますが、priority でキューに入れられたジョブを実行し続けます。

## 使用パターン

セッションは繰り返し実行されます。  これは、インタラクティブなタイムアウト内で送信されたジョブが即座に処理される、古典的なポスト処理を必要とするアルゴリズムに役立ちます。 代わりに一括でジョブを送信したい場合は、format@@0(run-jobs-batch) を参照してください。

例: 古典的な Scipy オプティマイザを使用してコスト関数を最小限に抑える反復的なワークロードを実行します。 このモデルでは、SciPYはコスト関数の出力を使用して次の入力を計算します。

```python
def cost_func(params, ansatz, hamiltonian, estimator):
    # Return estimate of energy from estimator

    energy = estimator.run(ansatz, hamiltonian, parameter_values=params).result().values[0]
    return energy

x0 = 2 * np.pi * np.random.random(num_params)

session = Session(backend=backend)

estimator = Estimator(session=session, options={"shots": int(1e4)})
res = minimize(cost_func, x0, args=(ansatz, hamiltonian, estimator), method="cobyla")

# Close the session because we didn't use a context manager.
session.close()
```

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - [量子近似最適化アルゴリズム(QAOA)](https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm) チュートリアルの例を試してみてください。 
  - format@@0(https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Session) リファレンスを確認してください。
</Admonition>
