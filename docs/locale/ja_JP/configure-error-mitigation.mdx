---
title: エラー緩和の設定
description: Qiskit Runtime でエラー緩和を設定します
---

# Qiskit Runtimeのエラー緩和を設定します

エラー緩和手法により、実行時のデバイスノイズを
モデリングすることにより、回路エラーを軽減することができます。 通常、
は、生成されたモデルを使用して生成された結果
のエラーを軽減するために、モデル訓練と
古典的な後処理オーバーヘッドに関連する量子前処理のオーバーヘッドを引き起こします。

プリミティブに組み込まれたエラー緩和手法は、高度な
回復力オプションです。 これらのオプションを指定するには、ジョブを送信するときに `resilience_level`
オプションを使用します。

回復力レベルは、
エラーに対してどれだけの回復力を構築するかを指定します。 レベルが高いほど、
処理時間が長くなり、より正確な結果が得られます。 抵抗レベルを使用して、プリミティブ
クエリにエラー軽減を適用する際の
コスト/精度トレードオフを設定できます。 エラー緩和は、
関連回路のコレクションまたはアンサンブルからの出力を処理することによって、結果としてエラー(バイアス)を軽減します。 
の誤差低減度は、適用される方法によって異なります。 回復力
レベルは、
ユーザーが
アプリケーションに適したコスト/精度取引について理解できるようにするエラー緩和方法の詳細な選択を抽象化します。

これを考えると、 それぞれのレベルは、
が量子サンプリングのオーバーヘッドを増加させる方法やメソッドに対応し、異なる時間精度のトレードオフで
を実験することができます。 以下の表は、プリミティブごとに使用可能なレベルとメソッドを示しています。

<Admonition type="info" title="Attention">
エラー緩和はタスク固有のもので、
手法は、分布をサンプリングするか、
期待値を生成するかどうかによって異なります。
</Admonition>

| 耐性レベル            | 定義                                                                                            | 推定値                                                                      | Sampler                                |
| ---------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ | -------------------------------------- |
| 0                | 緩和なし                                                                                          | なし                                                                       | なし                                     |
| 1 [Default]      | 最小の緩和コスト: 読み出しエラーに関連するエラーを軽減します。                                                              | Twirled Readout Error eXtinction (TREX)                                  | マトリックスフリー測定緩和(M3)                      |
| 2                | 中程度の緩和コスト。 通常、推定値のバイアスを減らしますが、バイアスがゼロであることは保証されません。                                           | ゼロノイズ外挿（ZNE）                                                             | -                                      |
| 3                | レイヤーサンプリングで重い緩和。 理論的にはゼロバイアス推定値を出すことが期待されている。                                                 | 確率的エラーキャンセル (PEC)                                                        | -                                      |

<Admonition type="info" title="Attention">

抵抗レベルは現在ベータレベルにあるため、サンプリングオーバヘッドと
ソリューションの品質は回路によって異なります。 新機能、
高度なオプション、および管理ツールはローリング
ベースでリリースされます。 具体的なエラー緩和方法が、各レジリエンスレベルで
適用されることは保証されていません。

</Admonition>

<Admonition type="note">
  Q-CTRLパフォーマンス管理が有効なIBM Cloud Qiskit Runtime サービスインスタンスを使用する場合 戦略に自動プリセットが含まれているので、ランタイム最適化や回復力レベルを指定する必要はありません。
  
  `optimization_level` または `resilience_level` を 0 に設定すると、
  実行エラーになります。 レベル1、2、3は許可されていますが、パフォーマンスに影響を与えることはありません。
  他のオプションを設定するとパフォーマンスにも影響しなくなり、
  ランタイム警告が発生する可能性があります。 詳細については、format@@0(https://docs.q-ctrl.com/q-ctrl-embedded)をご覧ください。
</Admonition>

## レジリエンスレベルで推定値を設定します

<details>
<summary>レジリエンスレベル 0</summary>

ユーザープログラムにエラー緩和は適用されません。

</details>

<details>
<summary>耐性レベル 1</summary>

レベル1は、特に
読み出しエラーに対処するエラー緩和方法を適用します。 推定値では、Twirled Readout Error eXtinction (TREX) として知られている
というモデルフリーの手法を適用します。 It reduces measurement error
by diagonalizing the noise channel associated with measurement by
randomly flipping qubits through X gates immediately before measurement,
and flipping the corresponding measured bit if an X gate was applied. 対角ノイズチャネルからの
再スケーリング用語は、ゼロ状態で初期化されたランダム回路を
ベンチマークすることによって学習されます。 これにより、
サービスは
読み出しノイズに起因する期待値からバイアスを取り除くことができます。 このアプローチは、量子期待値
(https://arxiv.org/abs/2012.09738)のための[Model-free
readout-error 軽減策](https://arxiv.org/abs/2012.09738)でさらに説明されています。

</details>

<details>
<summary>耐性レベル 2</summary>

レベル2では、異なるノイズ要素
に対して観測可能な
期待値を計算し、測定された期待値を
に使用して、ゼロノイズ制限(外挿
段階)で理想的な期待値を推定します。 このアプローチは期待値の誤差を減らす傾向がありますが、
は偏りのない結果を生成する保証はありません。

![ZNEメソッドのイラストレーション](/images/optimize/resiliance-2.png "ZNEメソッドのイラスト")

この方法のオーバーヘッドは、ノイズ係数の数に応じて拡大します。 
のデフォルト設定では、3つのノイズ因子で期待値をサンプルします。
は、この回復力レベルを採用するときのオーバーヘッドが約3倍になります。

</details>

<details>
<summary>耐性レベル 3</summary>

レベル3は、確率的なエラーキャンセル(PEC)法を有効にします。 この
アプローチは、相関するノイズを捕捉することができる疎ノイズモデル
を学習して反転することによってエラーを軽減します。 学習ノイズモデル
が緩和時の実際のノイズモデルを忠実に表している限り、PECは偏りのない
推定値を返します。
In practice, the experimental procedure for learning the noise model has
ambiguities due to certain error terms that cannot be independently
distinguished. これらは対称的な仮定によって解決されます 真の基礎となるノイズに応じて、
は不完全なノイズモデルを使用することにより、
の予測値を緩和することができます。

The Qiskit Runtime primitive implementation of PEC specifically
addresses noise in self-inverse two-qubit gates, so it first
_stratifies_ each input circuit into an alternating sequence of
simultaneous 1-qubit gates followed by a layer of simultaneous 2-qubit
gates. 次に、それぞれのユニークな
2量子ゲート層に関連するノイズモデルを学習します。

<figure>
<img src="/images/optimize/stratified.png" alt="/images/optimize/stratified.png" />
<figcaption>This is an example of a <span
class="title-ref">stratified</span> circuit, where the layers of
two-qubit gates are labeled layer 1 through n. Note that each <span
class="math inline"><em>U</em><sub><em>l</em></sub></span> is composed
of two-qubit gates on the native connectivity graph of the quantum
processor. 開いているボックスは任意のシングル量子ビット
ゲートを表します。</figcaption>
</figure>

この方法のオーバーヘッドは、ノイズ係数の数に応じて拡大します。 
のデフォルト設定では、3つのノイズ因子で期待値をサンプルします。
は、この回復力レベルを採用するときのオーバーヘッドが約3倍になります。

PEC uses a quasi-probability method to mimic the effect of inverting the
learned noise. これには、ユーザーの元の回路に関連付けられたランダム化回路ファミリ
からのサンプリングが必要です。 PECを適用すると、入力回路と
特性回路の両方で回路あたりの
サンプル数も増加しない限り、返される期待値の推定値のばらつきが
増加します。 
に対抗するために必要なサンプルの量は、緩和回路
のノイズ強度に応じて指数関数的に拡大します。

これがどのように機能するか:

計算されていないパウリが観測可能な$\\langle P\\rangle$ を推定すると、期待値の
標準誤差は次のようになります:

$\\frac{1}{\\sqrt{N\_{\\text{shots}}}}\\left(1- \\langle P\\rangle^2\\right)$

where $N_{\\text{shots}}$ は、
$\\langle P\\rangle$の推定に使われるショットの数です. PEC緩和を適用する場合 標準エラー
は
$\\sqrt{\\frac{S}{N_{\\text{samples}}}\\left(1- \\langle P\\rangle^2\\right)$
where $N\_{\\text{samples}}$ はPECサンプルの数です。

が入力回路の集団ノイズを特徴付けるパラメータで、サンプリングオーバーヘッドは指数関数的にスケールします。 As the Qiskit
Runtime primitive learns the noise of your circuit, it will return
metadata about the sampling overhead associated with that particular
layer. レイヤー $l$ のオーバーヘッドに $\\gamma_l$ のラベルを付けましょう。 次に、回路を軽減するための
合計サンプリングオーバーヘッドは、
の積です。つまり、以下のようになります。

$S = \\prod_l \\gamma_l$

推定値が原始的な
クエリのモデル学習フェーズを完了すると、
回路の合計サンプリングオーバーヘッドに関するメタデータが返されます。

アプリケーションで必要とされる精度に応じて、それに応じてサンプル数を拡大するには、
が必要です。 以下のプロット
は、異なる総サンプリングオーバーヘッドに対する推定誤差と
回路サンプルの数の関係を示しています。

![](/images/optimize/samping-overhead.png)

PECの学習段階で緩和スケーリング
因子が発見されるため、所望の精度
を提供するために必要なサンプル数はプリミティブクエリの前には分かっていないことに注意してください。

より大きな
問題を試みる前に、PECのサンプリングオーバーヘッドの
スケーリングの感触を得るための短い深度回路から始めることをお勧めします。

</details>

## 例

Estimatorインターフェースを使用すると、
のさまざまなエラー緩和方法とシームレスに連携し、
オブザベイの期待値の誤差を減らすことができます。 次のコードでは、単に
`resilience_level 2`を設定するだけでゼロノイズの外挿を使用します。

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options

service = QiskitRuntimeService()
options = Options()
options.resilience_level = 2
options.optimization_level = 3
backend = service.backend("ibmq_qasm_simulator")

estimator = Estimator(options=options, backend=backend)
job = estimator.run(circuits=[psi1], observables=[H1], parameter_values=[theta1])
psi1_H1 = job.result()
```

<Admonition type="info" title="Note">

回復力レベルを上げると、結果の精度を向上させるために追加のメソッドを使用することができます。 しかし、各レベルで方法が進歩するために、より正確な期待値を生成するために、サンプリングオーバーヘッド(時間)を追加する必要があります。 弾性レベルが高いほど品質が保証されないことに注意してください。 レベルが高いほどオーバーヘッドが大きくなります。 各方法には長所と短所があります。 例えば、TREX(Twirled Readout Error eXtinct)は読み出しエラーの軽減のため、浅い回路に適しています。 ZNE(ゼロノイズ外挿)は、より深い回路に適しています。 PECは任意のエラーを軽減することができますが、実際には大きなオーバーヘッドのために動作しない可能性があります。

</Admonition>

## サンプラーを回復力レベルで設定する

サンプラーのデフォルトの復元力設定(レベル1)では、読み出しエラー
の緩和を可能にし、ユーザーは緩和された準確率
分布を生成することができます。

<details>
<summary>耐性レベル 1</summary>

レベル1は、
読み出しエラーを軽減するために、マトリックスフリー測定緩和(M3)ルーチンを使用します。 M3は、ノイズの多い入力
ビットの文字列によって定義された短い空間で動作します。 Because the number of unique bit
strings can be much smaller than the dimensionality of the full
multi-qubit Hilbert space, the resulting linear system of equations is
nominally much easier to solve.

![M3メソッドのイラストレーション](/images/optimize/m3.png)

</details>

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options

service = QiskitRuntimeService()
options = Options()
options.resilience_level = 1
options.optimization_level = 3
backend = service.backend("ibmq_qasm_simulator")

sampler = Sampler(backend, options=options)
```

## 高度な回復力オプション

高度なオプションを調整して、回復力戦略
をさらに設定できます。 These methods can be used alongside resilience levels where you
change the specific options of interest and let your previously set
resilience level manage the rest.

As a part of the beta release of the resilience options, users will be
able configure ZNE by using the following advanced options. 
はPECを含む他の回復力レベルを調整するためのオプションを追加します。

| オプション                                                                                     | Inputs                          | 説明                                                                                                                      |
| ----------------------------------------------------------------------------------------- | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `options.resilience.noise_anmper(オプション\[str\])` <br/>  増幅戦略を選択します。                        | `TwoQubitAmplifier` [Default]   | すべての実行中のローカルゲート折り畳みノイズを増幅します。                                                                                           |
|                                                                                           | `CxAmplifier`                   | ローカルゲートの折り畳みを実行することで、すべてのCNOTゲートのノイズを増幅します。                                                                             |
|                                                                                           | `LocalFoldingAmplifier`         | ローカルゲートの折り畳みを実行することで、すべてのゲートのノイズを増幅します。                                                                                 |
|                                                                                           | `GlobalFoldingAmplifier`        | 入力回路全体の全体的な折り畳みを行うことによって、入力回路のノイズを増幅します。                                                                                |
| `options.resilience.noise_factors(Optional[Sequence[float]])`                             | (1, 3, 5)[Default]              | ノイズ増幅因子(ここで [1] はベースラインノイズを表します)。 それらはすべてベースライン以上である必要があります。                                                            |
| `options.resilience.extraolator(Optional\[str\])`                                         | `LinearExtrapolator`\[Default]  | 次数1の多項式外挿。                                                                                                              |
|                                                                                           | `2次外挿法`                         | 次数２以下の多項式外挿。                                                                                                            |
|                                                                                           | `Cubic Extrapolator`            | 次数３以下の多項式外挿。                                                                                                            |
|                                                                                           | `Quartic Extrapolator`          | 次数４以下の多項式外挿。                                                                                                            |

### 推定値プリミティブを使って `resilience_options` を追加する例

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options

service = QiskitRuntimeService()
options = Options()
options.optimization_level = 3
options.resilience_level = 2
options.resilience.noise_factors = (1, 2, 3, 4)
options.resilience.noise_amplifier = 'CxAmplifier'
options.resilience.extrapolator = 'QuadraticExtrapolator'
backend = service.backend("ibmq_qasm_simulator")

estimator = Estimator(options=options, backend=backend)
job = estimator.run(circuits=[psi1], observables=[H1], parameter_values=[theta1])
psi1_H1 = job.result()
```

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - IBM Quantum Learningの[Cost function lesson](https://learning.quantum.ibm.com/course/variational-algorithm-design/cost-functions#primitives)でエラー緩和を使用する例を紹介します。
  - [Q-CTRL](https://docs.q-ctrl.com/q-ctrl-embedded) についてもっと知る。
</Admonition>
