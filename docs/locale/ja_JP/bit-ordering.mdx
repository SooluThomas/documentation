---
title: Qiskit のビットオーダーメント
description: Qiskitの注文規則と私たちがそれらを選んだ理由について学ぶ
---

# Qiskit のビットオーダーメント

$n$ ビット（または量子ビット）の集合がある場合は、通常 $0
\\rightarrow n-1$ というラベルになります。 異なるソフトウェアやリソースは、コンピュータメモリと画面上に表示されるときに、
ビットをどのように並べるかを選択する必要があります。

## Qiskitの規則

Qiskit はさまざまなシナリオでビット注文を行います。

### Quantum circuits

`QuantumCircuit`クラスは、その量子ビットをリスト
(`QuantumCircuit.qubits`)に格納します。 このリストの量子ビットのインデックスは、
qubitのラベルを定義します。

```python
from qisKit import QuantumCircuit
qc = QuantumCircuit(2)
qc.qubits[0]  # qubit "0"
```

```
Qubit(QuantumRegister(2, 'q'), 0)
```

### 回路図

On a circuit diagram, qubit $0$ is the topmost qubit, and qubit $n$ the
bottommost qubit. これは
`QuantumCircuit.draw` の `reverse_bits` 引数で変更できます（[
Qiskitの順序変更](#change-ordering-in-qiskit)を参照してください）。

```python
qc.x(1)
qc.draw()
```

```
q_0: ────
     <unk> ────<unk>
q_1: <unk> X <unk>
     └────<unk>
```

### 整数

ビットを数値として解釈する場合、ビット $0$ は最も重要なビットであり、
ビット $n$ は最も重要なビットです。 これは、各ビットが
の値 $2^\\text{label}$ (ラベルは
`QuantumCircuit.qubits` の量子ビットインデックス) を持つため、コーディングに役立ちます。 For example, the following circuit execution ends
with bit $0$ being `0`, and bit $1$ being `1`. This is interpreted as the
decimal integer `2` (measured with probability `1.0`).

```python
from qiskit.primitives import Sampler
qc.measure_all()
Sampler().run(qc).result().quasi_dists[0]
```

```
{2: 1.0}
```

### 文字列

ビット(または量子ビット)のリストを文字列として表示または解釈する場合 ビット
$n$ が一番左側、ビット $0$ が一番右側です。 This is because we
usually write numbers with the most significant digit on the left, and in
Qiskit, bit $n$ is interpreted as the most significant bit.

例えば、以下のセルは、
シングルキュービット状態の文字列から `Statevector` を定義します。 この場合、qubit $0$ は状態 $|{+}\\rangle$, および
qubit $1$ in state $|0\\rangle$.

```python
from qiskit.quantum_info import Statevector
sv = Statevector.from_label("0+")
sv.probabilities_dict()
```

```
{'00': 0.4999999999999999, '01': 0.4999999999999999}
```

これはビットの文字列を解釈するときに混乱を招くことがある。
が期待する左端のビットはビット $0$ですが、通常はビット
$n$ を表します。

### ステートベクトル行列

複素数(振幅)のリストとして状態ベクトルを表す場合
Qiskit は、 $x$ の振幅が
計算基準状態 $|x\\r角度$を表すように、これらの振幅を注文します。

```python
print(sv[1]) 状態の # 振幅|01>
print(sv[2]) # 振幅の状態 |10>
```

```
(0.7071067811865475+0j)
0j
```

### ゲート

Qiskit の各ゲートは独自の方法でキュービットのリストを解釈できますが、
制御されたゲートは通常 `(control, target)` に従います。

例えば、次のセルでは、制御されたXゲートを追加します。ここでは、量子ビット $0$ が
制御され、量子ビット $1$ がターゲットです。

```python
from qisKit import QuantumCircuit
qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.draw()
```

```
q_0: ───
     <unk> ─<unk> ─<unk>
q_1: <unk> X <unk>
     └────<unk>
```

Qiskitで以前に述べたすべての規約に従ってください この CX-gate
は変換 $|01\\r角度 \\leftrightarrow |11\\rangle$を実行するため、
は行列に続く。

$
\\begin{pmatrix}
 1 & 0 & 0 & 0 \\
 0 & 0 & 0 & 1 \\
 0 & 0 & 1 & 0 \\
 0 0 & 1 & 0 & 0 \\
\\end{pmatrix}
$$

## Qiskit の順序を変更

逆順（つまり、 $0$ の下にある量子ビット
）で量子ビットを持つ回路を描くには、引数`reverse_bits`を使います。 これは生成された
ダイアグラムにのみ影響し、回路には影響しません。Xゲートは量子ビット $0$に対して動作します。

```python
from qisKit import QuantumCircuit
qc = QuantumCircuit(2)
qc.x(0)
qc.draw(reverse_bits=True)
```

```
q_1: ─────
     <unk> ────<unk>
q_0: <unk> X <unk>
     └────<unk>
```

`reverse_bits` メソッドを使って、
qubitsのラベルを逆にした新しい回路を返すことができます（これは元の回路を変更しません）。

```python
qc.reverse_bits().draw()
```

```
q_0: ────
     <unk> ────<unk>
q_1: <unk> X <unk>
     └────<unk>
```

この新しい回路では、Xゲートは量子ビット $1$に作用することに注意してください。

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - format@@2format@@3(https://learning.quantum.ibm.com/tutorial/grovers-algorithm) チュートリアルで回路の使用例を参照してください。
  - [QuantumCircuit API](/api/qiskit/qiskit.circuit.QuantumCircuit#quantumcircuit) リファレンスを探索します。
</Admonition>
