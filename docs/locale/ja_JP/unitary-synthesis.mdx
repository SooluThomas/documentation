---
title: 単一操作の合成
description: qubits上の任意のユニタリー行列の実装
---

# 単一操作の合成

単一演算は、量子系への標準保存の変更を記述します。
For $n$ qubits this change is described by a $2^n \\times 2^n$ dimensional, complex matrix $U$ whose adjoint equals the inverse, that is $U^\\dagger U = \\mathbb{1}$.

特定のユニタリー演算を一連の量子ゲートに合成することは、基本的な作業です。 例えば量子アルゴリズムの設計や応用や量子回路のコンパイルなどです

Cliffordゲートで構成されるものやテンソル製品構造を持つものなど、特定のクラスのユニットで効率的な合成が可能ですが、ほとんどのユニットはこれらのカテゴリに該当しません。
一般的な単一行列の場合、合成は量子ビットの数とともに指数関数的に増加する計算コストを持つ複雑な作業です。
したがって、実装したいユニタリーのための効率的な分解を知っている場合は、一般的な合成よりも良いでしょう。

<Admonition type="note">
    分解ができない場合、Qiskitは見つけるためのツールを提供します。 
    しかし、これは一般的にノイズの多い量子コンピュータ上では実行できない深い回路を生成することに注意してください。
</Admonition>

```python
import numpy as np
from qiskit import QuantumCircuit

U = 0.5 * np.array([
    [1, 1, 1, 1],
    [-1, 1, -1, 1],
    [-1, -1, 1, 1],
    [-1, 1, 1, -1]
])

circuit = QuantumCircuit(2)
circuit.unitary(U, circuit.qubits)
```

## 回路最適化のための再合成

長さを減らすことができる場合は、時にはそれはシングルと2量子ビットゲートの長いシリーズを再合成することが有益です。 例えば、以下の回路は3つの2量子ゲートを使用します。

![output](/images/build/unitary-s合成/unitary_target.png)

しかし、以下のコードで再合成した後は、単一のCXゲートしか必要ありません。

```python
from qiskit.quantum_info import Operator

# compute unitary matrix of target_circuit
U = Operator(target_circuit)

# re-synthesize
better_circuit = QuantumCircuit(2)
better_circuit.unitary(U, range(2))
better_circuit.decompose().draw()
```

![output](/images/build/unitary-synth.png)

Qiskitの [transpile](../api/qiskit/compiler#qiskit.compiler.transpile) 関数は、この再合成を十分に高い最適化レベルで自動的に実行します。

## 次のステップ

<Admonition type="tip" title="Recommendations">
  - [Grover's Algorithm](https://learning.quantum.ibm.com/tutorial/grovers-algorithm) チュートリアルで回路分解の例を参照してください。
  - Qiskit トランスパイラーの詳細については、format@@0(../transpile/index) をご覧ください。
</Admonition>
