---
title: 量子コンピューターを表現する
description: マップ、基礎ゲート、およびバックエンドエラーの結合について学ぶ
---

# 量子コンピュータの概要

特定のバックエンドで実行できる等価回路を構築するには、トランスパイラーはバックエンドについて特定の詳細を必要とします。  通常、この情報は `backend` クラスまたは `target = backend.target` クラスで見つかるので、トランスパイラーにこれ以上何も渡す必要はありません。 しかし、より多くの情報が提供される場合、トランスパイラーはそれを使用して、そのハードウェア上で実行するための最良の回路を生成することができます。  

<Admonition type="note">
基礎となるトランスパイルアルゴリズムの多くは確率的であるため、より良い回路が見つかる保証はありません。 
</Admonition>

<span id="default-config"></span>
## デフォルト設定

トランスパイラーの最も単純な使い方は、`backend` または `target` を指定することで、バックエンド情報をすべて提供することです。 トランスパイラーがどのように動作するかをよりよく理解するために、回路を構築し、異なる情報を使用してトランスパイルします。

必要なライブラリをインポートし、バックエンドをインスタンス化します。

```python
from qisKit import transpile
from qiskit.circuit.Library import EfficientSU2
from qiskit.providers.fake_provider import FakeSherbrooke

backend = FakeSherbrooke()
target = backend.target
```

`EfficientSU2`回路は、`SU(2)`と`CX`のエンタングルメントで構成される単一の量子ビット演算の層で構成されています。 これはヒューリスティックなパターンで、変動量子アルゴリズムや機械学習のための分類回路の試験波関数を準備するために使用できます。

```python
qc = EfficientSU2(12, entanglement='circular', reps=1)
qc.decompose(reps=1).draw('mpl', style='iqp')
```

![The 12-qubit test circuit](/images/transpile/representing_quantum_computers/qc-circular.png)

### 回路をバックエンドターゲットにトランスパイル

この例ではデフォルトの `optimization_level=1` を使用して、 `backend` `target` に移行します。 バックエンドで動作するように回路を変換するのに必要なトランスパイラーにすべての情報を提供する

```python
qc_t_target = transpile(qc, target=target, seed_transpiler=12345)
qc_t_target.draw('mpl', style='iqp', idle_wires=False)
```

![The transpled 12-qubit ansatz using Target information](/images/transpile/representing_quantum_computers/qc_t_target.png)

この例は、このトピックの後のセクションで使用されています。カップリング・マップとベース・ゲートは、最適な回路構築のためにトランスパイラに渡すために不可欠な情報の部分であることを示します。 バックエンドは通常、渡されない他の情報(タイミングやスケジュールなど)についてデフォルトの設定を選択できます。

ゲートのエラー率を含むバックエンドプロパティを提供することで、トランスパイラーはバックエンド上で最適な qubit を選択することができます。

## カップリングマップ

カップリングマップは、どの量子ビットが接続されているかを示すグラフであり、それらの間に2量子ビットゲートがあります。 このグラフは方向になることがあります。つまり、2量子ビットゲートは一方向にしか行えないことになります。 ただし、トランスパイラーは追加の1量子ビットゲートを追加することで、常にゲートの方向を反転させることができます。 抽象量子回路は、接続性が限られていても、このグラフでは常に表現することができます。 SWAPゲートを導入して量子情報を移動させます 

抽象回路の量子ビットは _virtual qubits_ と呼ばれ、カップリングマップの量子ビットは _physical qubits_ と呼ばれます。 トランスパイラーは仮想キュービットと物理キュービット間のマッピングを提供します。 移調の最初のステップの一つである _routing_ ステージは、このマッピングを実行します。

<Admonition type="note">
ルーティングステージは _layout_ ステージと絡み合っています。 実際の量子ビットを選択しますが、それらを単純化のための別の段階として検討します。 ルーティングとレイアウトの組み合わせは _qubit mapping_と呼ばれます。  format@@0(transpiler-stages) のトピックで、これらのステージの詳細をご覧ください。
</Admonition>

`coupping_map` キーワード引数を渡してトランスパイラーに影響を与えます。

```python
coupping_map = target.build_coupping_map()

qc_t_cm_lv0 = transpile(qc, coupling_map=coupping_map, optimization_level=0, seed_transpiler=11)
qc_t_cm_lv0.draw('mpl', style='iqp', idle_wires=False)
```

![Ansatz transpiled to coupling map with optimization level 0](/images/transpile/representing_quantum_computers/qc_t_cm_lv0.png)

上記のように、複数のSWAPゲート(それぞれ3つのCXゲートからなる)が挿入され、現在のデバイスでは多くのエラーが発生します。 実際の量子トポロジでどの量子ビットが選択されているかを確認するには、Qiskit Visualizationの「plot_circuit_layout」を使用します。

```python
from qiskit.visibility import plot_circuit_layout

plot_circuit_layout(qc_t_cm_lv0, backend, view='physical')
```

![Circuit Layout for optimization level 0](/images/transpile/representing_quantum_computers/circ_layout_lv0.png)

これは、仮想量子ビット0-11が物理的な量子ビット0-11の行にささやかにマッピングされていることを示しています。 必要に応じて`VF2Layout`を使用するデフォルト（`optimization_level=1`）に戻りましょう。

```python
qc_t_cm_lv1 = transpile(qc, coupling_map=coupping_map, seed_transpiler=11)
qc_t_cm_lv1.draw('mpl', style='iqp', idle_wires=False)
```

![Ansatz transpiled to coupling map with optimization level 1](/images/transpile/representing_quantum_computers/qc_t_cm_lv1.png)

SWAP ゲートが挿入されておらず、`target` クラスを使用して選択された物理キュービットも同じです。

```python
from qiskit.visibility import plot_circuit_layout

plot_circuit_layout(qc_t_cm_lv1, backend, view='physical')
```

![Circuit Layout for default optimization level](/images/transpile/representing_quantum_computers/circ_layout_lv1.png)

今、レイアウトはリングにあります。  このレイアウトは回路の接続性を尊重しているため、SWAPゲートはありませんので、より優れた回路を実行することができます。

## 基底門

すべての量子バックエンドは _basis gates_ と呼ばれる限定的な命令セットをサポートしています。  回路内のすべてのゲートは、このセットの要素に変換する必要があります。 このセットは、ユニバーサルゲートセットを提供する単一および2量子ビットのゲートで構成する必要があります。 つまりどんな量子演算でもゲートに分解できるということです  これは、 [BasisTranslator](../api/qiskit/qiskit.transpiler.passes.BasisTranslator)によって行われ、この情報を提供するためにトランスパイラーのキーワード引数として基底ゲートを指定することができます。

```python
basis_gates = list(target.operation_names)
print(basis_gates)
```

```python
['rz', 'sx', 'x', 'ecr', 'measure', 'delay']
```

_ibm_sherbrooke_ のデフォルトの単一量子ビットゲートは `rz`、`x`、`sx`です。デフォルトの 2 量子ビットゲートは `ecr`で、エコーされたクロス共鳴を表します。 CXゲートは`ecr`ゲートから構築されます。したがって、いくつかのバックエンドでは`ecr`は2量子ベースゲートとして指定され、他では`cx`はデフォルトです。 `ecr`ゲートは、`cx`ゲートの_entangling_部分です。 ベースゲートセットにないゲートを使用したい場合は、format@@0(https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PulseGates#pulsegates)を使用してカスタムゲートの命令を提供できます。 制御ゲートに加えて、「delay」と「measurement」の命令もあります。

<Admonition>
    バックエンドにはデフォルトのベース・ゲートがありますが、任意のゲートを選択できます。 命令またはパルスゲートを追加する限り(format@@0を参照)。 (custom-transpiler-pass)) デフォルトのベース・ゲートは、バックエンドでキャリブレーションが行われているゲートです。したがって、これ以上の命令/パルス・ゲートを提供する必要はありません。 例えば、いくつかのバックエンドの `cx` はデフォルトの 2 量子ビットゲートと `ecr` です。
</Admonition>

```python
qc_t_cm_bg = transpile(qc, coupling_map=coupling_map, basis_gates=basis_gates, seed_transpiler=11)
qc_t_cm_bg.draw('mpl', style='iqp', fold=-1, idle_wires=False)
```

![Ansatz transpiled to coupling map and basis gates](/images/transpile/representing_quantum_computers/qc_t_cm_bg_lv1.png)

`CXGate`は`ecr`ゲートとシングルキュービットベースゲートに分解されていることに注意してください。

## バックエンドエラーを含む

`target` オブジェクトを構築すると、 `coupping_map` と `basis_gates` に加えて、量子ビットのエラー率を考慮することができます。  `target` オブジェクトにはバックエンドをターゲットするために必要なすべてのものが含まれていますが、ここでは限られた量の情報を含むものを構築します。

以前に `backend.target` から `target` を取得しました。 これはエラー率を含む多くのバックエンド情報が含まれています。 例えば、 qubit 0 と 1 の間のエコーされたクロス共鳴ゲートの命令プロパティ (`ecr`は方向ではありません) は、次のコマンドを実行して取得します。

```python
target['ecr'][(1, 0)]
```

```
InstructionProperties(duration=5.3333333333332e-07, error=0.0069730734746021, calibration=PulseQobj)
```

上記の結果は、ゲートが533μsで誤差が0.7%であることを示しています。 トランスパイラーにエラー情報を表示するには 上から `basis_gates` と `coupping_map` を使用して独自のターゲットモデルを構築し、バックエンドの `FakeSherbrooke` からエラー値を入力します。 

```python
from qiskit.transpiler import Target

err_targ = Target.from_configuration(basis_gates=basis_gates, coupling_map=coupling_map, num_qubits=target.num_qubits)

for idx in range(len(target.instructions)):
    err_targ[target.instructions[idx][0].name][target.instructions[idx][1]] = target.instruction_properties(idx)
```

新しいターゲット `err_targ` をターゲットにしたトランスパイル: 

```python
qc_t_cm_bg_et = transpile(qc, target=err_targ, seed_transpiler=11)
qc_t_cm_bg_et.draw('mpl', style='iqp', fold=-1, idle_wires=False)
```

![Ansatz transpiled to our target model](/images/transpile/representing_quantum_computers/qc_t_cm_bg_et_lv1.png)

エラー情報を含めることで、`VF2PostLayout`パスは使用する最適な量子ビットを見つけようとします。 同じ物理量子ビットを持つ回路を発見しました

## 次のステップ

<Admonition type="tip" title="Recommendations">
    - 理解する [Transpilation default settings and configuration-options](defaults-and-configuration-options)
    - [Transpilationに通常使用されるパラメータ](common-parameters) topicを確認してください。 
    - format@@0(https://learning.quantum.ibm.com/tutorial/submit-transpled-circuits) チュートリアルを試してみてください。
    - [Transpile API documentation.](/api/qiskit/transpiler)
</Admonition> を参照してください。
