---
title: Quantum Serverless を使用してワークロードをリモートで実行
description: Quantum Serverless を使用してワークロードをリモートで実行
---

# Quantum Serverless を使用してワークロードをリモートで実行

プレミアムユーザーは、IBM Quantum Platformを通じて利用可能な古典的な計算で、ワークロードをリモートでビルド、デプロイ、および実行できます。

[IBM Quantum Learning](https://learning.quantum.ibm)でチュートリアルを試してみてください。 om/catalog/tutorials? opics=qiskit-patterns) (注:IBM Quantum アカウントにログインするとプレミアムプランでアクセスでき、 [documentation](https://qiskit-extensions) でQuantum Serverless の機能をさらに詳しく調べることができます。 ithub.io/quantum-serverless/).

<Admonition type="note">
    これは実験的な機能であり、変更される可能性があります。
</Admonition>

## Quantum Serverless の Qiskit パターン

ユーティリティスケールの量子アプリケーションを作成するには、一般的に、さまざまなコンピューティングリソース要件が必要です。 Quantum Serverless を使用すると、リモートで管理された実行のための量子ワークフローを簡単に送信できます。 これらの量子ワークフローは通常、Qiskit Patternと呼ばれる共通パターン内で実装することができます。 Qiskit Pattern は、量子コンピューティングワークフローを実装するための直感的で繰り返し可能な一連のステップです。

Qiskit パターン内のステップ:

1.  古典入力を量子問題にマップする
2.  量子実行の問題を最適化する
3.  Qiskit Runtime プリミティブを使用して実行
4.  ポストプロセス、古典的なフォーマットで結果を返します

Qiskit Patternをビルドしたら、Quantum Serverlessを使用してデプロイし、管理された実行のために送信することができます。 全体として、量子ソフトウェアを作成し、リモートクラスターで管理された実行のために送信するプロセスを3つのステップに分けることができます。

1.  Qiskit パターンを構築する
2.  Quantum Serverless にデプロイする
3.  Quantum Serverless でリモートで実行

## Qiskit パターンを構築する

QisKit Runtime Estimate プリミティブを使用して期待値を計算する例を以下に示します。 この Python スクリプトは作業ディレクトリに保存する必要があります。 (警告! 作業ディレクトリのすべての内容は、実行のためにクラスタに出荷されます。

```python
# source_files/my_qiskit_pattern.py

from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.circuit.random import random_circuit
from qiskit.quantum_info import SparsePauliOp
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator
from quantum_serverless import save_result

service = QiskitRuntimeService()
backend = service.least_busy(simulator=False)

# Step 1: Map quantum circuits and operators
abstract_circuit = random_circuit(2, 2, seed=1234)
observable = SparsePauliOp("IY")

# Step 2: Optimize the circuit for quantum execution
pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
target_circuit = pm.run(abstract_circuit)
target_observable = observable.apply_layout(target_circuit.layout)

# Step 3: Execute the target circuit
estimator = Estimator(backend)
job = estimator.run(target_circuit, target_observable)
result = job.result()

# Step 4: Postprocess the results
print(result)

# save results of program execution
# note: saved items must be serializable
save_result(result.values)
```

パターンをformat@@0(https://qiskit-extensions.github.io/quantum-serverless/getting_started/basic/02_arguments_and_results.html)と[外部python依存関係を処理する](https://qiskit-extensions.github.io/quantum-serverless/getting_started/basic/03_dependencies.html)に設定する方法については、ガイドを参照してください。

ワークフローを作成した後、IBM Quantum トークンを使用して `IBMServerlessProvider` を認証し、format@@0(https://quantum) から取得できます。 bm.com/account)、スクリプトをアップロードします。

```python
# Authenticate to the IBM serverless provider
from quantum_serverless import IBMServerlessProvider
serverless = IBMServerlessProvider("YOUR_IBM_QUANTUM_TOKEN")

# Deploy the pattern
from quantum_serverless import QiskitPattern
serverless.upload(
    QiskitPattern(
        title="My-Qiskit-Pattern",
        entrypoint="my_qiskit_pattern.py",
        working_dir="./source_files/"
    )
)
```

## Quantum Serverless で Qiskit Pattern をリモートで実行する

最後に、パターンはリモートで実行する準備ができています。

```python
# リモートで
job = serverless.run("My-Qiskit-Pattern")

# ステータス、ログ、結果
job.status()
job.logs()
job.result()
```

## 移行ガイド

Qiskit ランタイムのカスタムプログラムは、このformat@@0(https://qiskit-extensions.github.io/quantum-serverless/migration/migration_from_qiskit_runtime_programs.html)を介して、簡単にQuantum Serverlessに移行できます。

## リソース管理 (アルファ)

プレミアムプランのユーザーは、Quantum Serverless を介してリソース管理機能のアルファリリースにアクセスできます。 これにより、ワークロード用の量子ハードウェアの自動選択が可能になります。

以下の例では、利用可能なバックエンドのセットから使用する qubit を選択するプロセスを自動化するために `IBMQPUSelector` を使用する方法を示します。 ここでは、4ステップの Qiskit パターン内でセレクターを使用する方法を示します。 

バックエンドを手動で選択するかわりに。 QisKit Pattern のステップ2では、Quantum Serverless の QPUセレクタを使用して、必要な条件に応じてバックエンドを自動的に割り当てることで、実行のための回路を最適化します。 ここで、`IBMLeastNoisyQPUSelector`は、IBM Quantumアカウントを通じて利用可能なバックエンドを見つけます。 これにより、入力回路のノイズの少ない量子ビットサブグラフが得られます。 `IBMLeastBusyQPUSelector` を使用して、回路の幅をサポートできるバックエンドを見つけることもできますが、キューの最短です。

それぞれの `IBMQPUSelector` に対して、コンテキストはコンストラクタで設定されます。 すべての `IBMQPUSelectors` には Qiskit Runtime 資格情報が必要です。 `IBMLeastNoisyQPUSelector` では、最適なQPUとQPUレイアウトを決定する際に、各バックエンドに対して回路を最適化する方法を指定する回路とトランスパイルオプションが必要です。 すべての `IBMQPUSelector` は `get_backend` メソッドを実装しており、与えられたコンテキストに対して最適なバックエンドを取得します。 `get_backend` メソッドはバックエンドをフィルタリングすることもできます。 これは、[QiskitRuntimeService.backends メソッド](/api/qiskit-ibm-runtime/qiskit_ibm_runtime.QiskitRuntimeService#backends)と同じインターフェースを使用して実装されています。

次に、パターンのステップ3で、セレクタが選択したバックエンドでターゲット回路を実行します。 ステップ2でバックエンド用の回路を最適化したので、`skip_transpilation=True`を設定することで、プリミティブ内のトランスパイルをスキップできます。 

```python
# source_files/my_qiskit_pattern_resource_management.py

from qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler, Options
from qiskit.circuit.random import random_circuit
from quantum_serverless_tools.selectors import IBMLeastNoisyQPUSelector

service = QiskitRuntimeService()

# Step 1: Map quantum circuits and operators
abstract_circuit = random_circuit(
    num_qubits=5, depth=4, measure=True, seed=1234
)

# Step 2: Optimize the circuit for quantum execution with automatically selected backend
selector = IBMLeastNoisyQPUSelector(
    service, circuit=abstract_circuit, transpile_options={"optimization_level": 3}
)
backend = selector.get_backend(min_num_qubits=127)
target_circuit = selector.optimized_circuit

## Alternatively, one can automatically select a backend according to most available:
# from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
# from quantum_serverless_tools.selectors import IBMLeastBusyQPUSelector
#
# backend = IBMLeastBusyQPUSelector(service).get_backend(min_num_qubits=127)
# pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
# target_circuit = pm.run(abstract_circuit)

# Step 3: Execute the target circuit
with Session(service, backend=backend) as session:
    sampler = Sampler(
        options=Options(
            execution={"shots": 1024}, transpilation={"skip_transpilation": True}
        )
    )
    result = sampler.run(target_circuit).result().quasi_dists[0]

# Step 4: Postprocess the results
print(result)

# save results of program execution
# note: saved items must be serializable
save_result(result)
```

このパターンを作成したら、上記のように Quantum Serverless を使用してリモートで実行できます。
